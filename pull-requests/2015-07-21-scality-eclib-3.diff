diff --git a/.gitignore b/.gitignore
index a81d871..75045c3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,6 +7,11 @@ pids
 *.pid
 *.seed
 
+# Erasure coding libs
+erasurecode
+gf_complete
+Jerasure
+
 # Directory for instrumented libs generated by jscoverage/JSCover
 lib-cov
 
@@ -27,5 +32,5 @@ build/*
 # https://www.npmjs.org/doc/misc/npm-faq.html#should-i-check-my-node_modules-folder-into-git
 node_modules
 
-# temptest.js should not be in the repo 
+# temptest.js should not be in the repo
 test/temptest.js
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..c2111e3
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,54 @@
+TARGET		= build/Release/node-eclib.node
+GF			= gf_complete
+JERASURE	= Jerasure
+LIBERAS		= erasurecode
+
+LIBDIR		= /usr/local/lib
+LIBS		= $(addsuffix .so, $(GF) $(JERASURE) $(LIBERAS))
+DEPS		= $(addprefix $(LIBDIR)/lib, $(LIBS))
+
+LIB_EXT := so
+ifeq ($(shell uname -s), Darwin)
+	LIB_EXT := dylib
+endif
+LIB_GUARD := find /usr 2>/dev/null -name '*.$(LIB_EXT)' | grep
+
+all: $(DEPS)
+
+$(GF):
+	$(LIB_GUARD) libgf_complete.$(LIB_EXT) || git clone http://lab.jerasure.org/jerasure/gf-complete.git $@
+
+$(GF)/Makefile: | $(GF)
+	$(LIB_GUARD) libgf_complete.$(LIB_EXT) || ( cd $(GF) && ./autogen.sh && ./configure )
+
+$(LIBDIR)/libgf_complete.so: $(GF)/Makefile
+	$(LIB_GUARD) libgf_complete.$(LIB_EXT) || ( $(MAKE) -C $(GF) && sudo $(MAKE) -C $(GF) install )
+
+$(JERASURE):
+	$(LIB_GUARD) libJerasure.$(LIB_EXT) || git clone http://lab.jerasure.org/jerasure/jerasure.git $@
+
+$(JERASURE)/Makefile: | $(JERASURE)
+	$(LIB_GUARD) libJerasure.$(LIB_EXT) || ( cd $(JERASURE) && autoreconf --force --install -I m4 && ./configure )
+
+$(LIBDIR)/libJerasure.so: $(JERASURE)/Makefile
+	$(LIB_GUARD) libJerasure.$(LIB_EXT) || ( $(MAKE) -C $(JERASURE) && sudo $(MAKE) -C $(JERASURE) install )
+
+$(LIBERAS):
+	$(LIB_GUARD) liberasurecode.$(LIB_EXT) || git clone https://bitbucket.org/tsg-/liberasurecode.git $@
+
+$(LIBERAS)/Makefile: | $(LIBERAS)
+	$(LIB_GUARD) liberasurecode.$(LIB_EXT) ||  ( cd $(LIBERAS) && ./autogen.sh && ./configure )
+
+$(LIBDIR)/liberasurecode.so: $(LIBERAS)/Makefile
+	$(LIB_GUARD) liberasurecode.$(LIB_EXT) || ( $(MAKE) -C $(LIBERAS) && $(MAKE) -C $(LIBERAS) test \
+		&& sudo $(MAKE) -C $(LIBERAS) install )
+
+clean:
+	$(RM) $(TARGET)
+
+distclean: clean
+	$(RM) -r $(GF) $(JERASURE) $(LIBERAS)
+
+re: distclean all
+
+.PHONY: all clean distclean re
diff --git a/README.md b/README.md
index 03e4e20..70befa5 100644
--- a/README.md
+++ b/README.md
@@ -1,38 +1,51 @@
 # Node-ECLib
 ===================
-This is the node port of required library 
+This is the node port of required library
 https://bitbucket.org/tsg-/liberasurecode
 
-Here is the main libraray Web site,
+Here is the main library Website,
 http://jerasure.org
 
-Here is the python warpper of liberasurecode library
+Here is the python wrapper of liberasurecode library
 https://bitbucket.org/kmgreen2/pyeclib
 
-To understand how the liberasurecode methods works please go though this class,
+To understand how the liberasurecode methods works, please go through this
+class,
 https://bitbucket.org/tsg-/liberasurecode/src/e46c434e36566f6f0820923a9a184e27d7b941e8/test/liberasurecode_test.c?at=master
 
 ------------
 
 ### Setup
 =========
-Please see the SETUP.md file for the setup details.
+A simple command will take care of everything for you:
+```sh
+npm install -g node-gyp # you might need to be root for this command
+npm install
+```
+The install process will need to install libraries and node-gyp, requiring
+sudo usage.
+
+Running the test is done via the usual:
+```sh
+npm test
+```
 
 
 ### Prestudy
 ===========
-If you develop addons earlier then you probably knew it if not then it would be really helpfull to read these,
-https://github.com/iojs/nan
+If you developed addons before, then you probably knew it. If not, it would
+be really helpful to read this:
+[nan-documentation](https://github.com/iojs/nan)
 
 
 ### Project structure
 ============
-Here is the details
+Here are the details
 
 ## Js Files
-* eclib-enum.js # 
+* eclib-enum.js #
 	This file will contain all the enum values that was introduced in the c project to keep the simillarity among the projects.
-* eclib-util.js # 
+* eclib-util.js #
 	This contain all the util method that was required by the node-eclib.js file
 * node-eclib.js #
 	This file has some commented out code, please go through it. Initially it was a strait forward implementation. Currently the class has only the skeleton of the methods.
@@ -43,6 +56,6 @@ Here is the details
 * asyncencode.cpp # This class holds all the encode methods. Partially implemented .(Previous plan was to use NAN's asyn task for encoding)
 * asyncreconstruction.cpp # Just a dummy class for exposing fragment reconstruction
 * libmain.cpp # This class will have all the method except those 5 methods. Partially implemented.
-* Libutil.cpp # This class holds the util method for the all the classes. Just few methods are implemented here.
+* libutil.cpp # This class holds the util method for the all the classes. Just few methods are implemented here.
 
 ---------
diff --git a/binding.gyp b/binding.gyp
index d7804b7..bda3c50 100644
--- a/binding.gyp
+++ b/binding.gyp
@@ -2,18 +2,28 @@
   "targets": [
     {
       "target_name": "node-eclib",
-      "sources": [ "src/cpp/node-eclib.cpp"
-      			,"src/cpp/libmain.cpp" 
-      			,"src/cpp/asyncencode.cpp"
-      			,"src/cpp/asyncdecode.cpp"
-            ,"src/cpp/asyncreconstruction.cpp"
-            ,"src/cpp/libutil.cpp" 
-      			],
+      "sources": [
+        "src/cpp/node-eclib.cpp",
+        "src/cpp/libmain.cpp",
+        "src/cpp/asyncencode.cpp",
+        "src/cpp/asyncdecode.cpp",
+        "src/cpp/asyncreconstruction.cpp",
+        "src/cpp/libutil.cpp"
+      ],
       "include_dirs" : [
-          "<!(node -e \"require('nan')\")"
-          ],
-      "libraries": [ "/usr/local/lib/liberasurecode.so" ]
-      
+        "/usr/local/include/liberasurecode",
+        "<!(node -e \"require('nan')\")"
+      ],
+      "conditions": [
+        ['OS=="mac"', {
+          "libraries": [ "/usr/local/lib/liberasurecode.dylib" ]
+        }],
+        ['OS=="linux"', {
+          "libraries": [
+            "$(shell out=`ldconfig -p | grep liberasurecode.so` && ldconfig -p | grep liberasurecode.so | rev | cut -d' ' -f1 | rev | sed 's/[^\/]\+$$//g' | sed -n '1p' | tr -d '\\n' && echo 'liberasurecode.so' || echo /usr/local/lib/liberasurecode.so)"
+          ]
+        }]
+      ]
     }
   ]
 }
diff --git a/eclib-enum.js b/eclib-enum.js
index 56d09a7..74d6741 100644
--- a/eclib-enum.js
+++ b/eclib-enum.js
@@ -1,32 +1,32 @@
 // This class will be act as  the enum container for the node-eclib module
 
 module.exports = {
-    BackendId: {
-	    "EC_BACKEND_NULL" 					: 0,
-	    "EC_BACKEND_JERASURE_RS_VAND" 		: 1,
-	    "EC_BACKEND_JERASURE_RS_CAUCHY" 	: 2,
-	    "EC_BACKEND_FLAT_XOR_HD" 			: 3,
-	    "EC_BACKEND_ISA_L_RS_VAND" 			: 4,
-	    "EC_BACKEND_SHSS" 					: 5,
-	    "EC_BACKENDS_MAX" 					: 99
-    },
+  BackendId: {
+    "EC_BACKEND_NULL": 0,
+    "EC_BACKEND_JERASURE_RS_VAND": 1,
+    "EC_BACKEND_JERASURE_RS_CAUCHY": 2,
+    "EC_BACKEND_FLAT_XOR_HD": 3,
+    "EC_BACKEND_ISA_L_RS_VAND": 4,
+    "EC_BACKEND_SHSS": 5,
+    "EC_BACKENDS_MAX": 99
+  },
 
-    ChecksumType: {
-    	"CHKSUM_NONE"		: 1,
-	    "CHKSUM_CRC32" 		: 2,
-	    "CHKSUM_MD5" 		: 3,
-	    "CHKSUM_TYPES_MAX" 	: 99
-    },
+  ChecksumType: {
+    "CHKSUM_NONE": 1,
+    "CHKSUM_CRC32": 2,
+    "CHKSUM_MD5": 3,
+    "CHKSUM_TYPES_MAX": 99
+  },
 
-    ErrorCode : {
-    	"EBACKENDNOTSUPP" 		: 200,
-	    "EECMETHODNOTIMPL" 		: 201,
-	    "EBACKENDINITERR" 		: 202,
-	    "EBACKENDINUSE" 		: 203,
-	    "EBACKENDNOTAVAIL" 		: 204,
-	    "EBADCHKSUM" 			: 205,
-	    "EINVALIDPARAMS" 		: 206,
-	    "EBADHEADER" 			: 207,
-	    "EINSUFFFRAGS" 			: 208
-    }
+  ErrorCode: {
+    "EBACKENDNOTSUPP": 200,
+    "EECMETHODNOTIMPL": 201,
+    "EBACKENDINITERR": 202,
+    "EBACKENDINUSE": 203,
+    "EBACKENDNOTAVAIL": 204,
+    "EBADCHKSUM": 205,
+    "EINVALIDPARAMS": 206,
+    "EBADHEADER": 207,
+    "EINSUFFFRAGS": 208
+  }
 };
diff --git a/eclib-util.js b/eclib-util.js
index bae2780..8189f9f 100644
--- a/eclib-util.js
+++ b/eclib-util.js
@@ -1,89 +1,91 @@
 // All the util method will go here.
-// Lets see how many methods do we need add here, might be in the future we goona need 
+// Lets see how many methods do we need add here, might be in the future we goona need
 //		another validator util
 
 var enums = require("./eclib-enum.js");
 
-function ECLibUtil(){
+function ECLibUtil() {
 
-	this.isInt = function(n){
+	this.isInt = function(n) {
 		return typeof n === 'number' && n % 1 == 0;
 	}
 }
 
-ECLibUtil.prototype.getErrorMessage = function(errorcode){
+ECLibUtil.prototype.getErrorMessage = function(errorcode) {
 
 	var errornumber = enums.ErrorCode;
- 	var message = null;
+	var message = null;
 
-	switch(errorcode){
-		case -errornumber.EBACKENDNOTSUPP :
-			message = "Backend not supported"; 
+	switch (errorcode) {
+		case -errornumber.EBACKENDNOTSUPP:
+			message = "Backend not supported";
 			break;
-		
-		case -errornumber.EECMETHODNOTIMPL :
-			message = "No method implemented"; 
+
+		case -errornumber.EECMETHODNOTIMPL:
+			message = "No method implemented";
 			break;
-		
-		case -errornumber.EBACKENDINITERR :
-			message = "Backend instance is terminated"; 
+
+		case -errornumber.EBACKENDINITERR:
+			message = "Backend instance is terminated";
 			break;
-		
-		case -errornumber.EBACKENDINUSE :
-			message = "Backend instance is in use"; 
+
+		case -errornumber.EBACKENDINUSE:
+			message = "Backend instance is in use";
 			break;
-		
-		case -errornumber.EBACKENDNOTAVAIL :
-			message = "Backend instance not found"; 
+
+		case -errornumber.EBACKENDNOTAVAIL:
+			message = "Backend instance not found";
 			break;
-		
-		case -errornumber.EBADCHKSUM :
-			message = "Fragment integrity check failed"; 
+
+		case -errornumber.EBADCHKSUM:
+			message = "Fragment integrity check failed";
 			break;
-		
-		case -errornumber.EINVALIDPARAMS :
-			message = "Invalid arguments"; 
+
+		case -errornumber.EINVALIDPARAMS:
+			message = "Invalid arguments";
 			break;
-		
-		case -errornumber.EBADHEADER :
-			message =  "Fragment integrity check failed"; 
+
+		case -errornumber.EBADHEADER:
+			message = "Fragment integrity check failed";
 			break;
-		
-		case -errornumber.EINSUFFFRAGS :
-			message = "Insufficient number of fragments"; 
+
+		case -errornumber.EINSUFFFRAGS:
+			message = "Insufficient number of fragments";
 			break;
-			
+
 		default:
 			message = "Unknown error";
 			break;
 	}
 
 	return message;
-}; 
+};
 
-ECLibUtil.prototype.validateInstanceCreateParams = function( ec_backend_id, k, m, w, hd, ct){
+ECLibUtil.prototype.validateInstanceCreateParams = function(ec_backend_id, k, m,
+	w, hd, ct) {
 
 	var retvalue = true;
 	var argslength = arguments.length;
 
 	retvalue = (argslength == 6);
 
-	while ( retvalue && (argslength> 0) ){
-		retvalue = retvalue && this.isInt( arguments[argslength - 1]);
+	while (retvalue && (argslength > 0)) {
+		retvalue = retvalue && this.isInt(arguments[argslength - 1]);
 		argslength--;
 	}
 
 	return retvalue;
 };
 
-ECLibUtil.prototype.validateEncodeParams = function( ec_id, orig_data, deta_length,callback ){
+ECLibUtil.prototype.validateEncodeParams = function(ec_id, orig_data,
+	deta_length, callback) {
 
 	var retvalue = true;
 	var argslength = arguments.length;
 
 	retvalue = (argslength == 4);
-	retvalue = retvalue && this.isInt( arguments[0]);
-	retvalue = retvalue && this.isInt( arguments[2]);
+	retvalue = retvalue && this.isInt(arguments[0]);
+	retvalue = retvalue && this.isInt(arguments[2]);
 	retvalue = retvalue && (orig_data !== undefined) && Buffer.isBuffer(orig_data);
 	// Will check whether the callback is a method or not
 	//retvalue = retvalue && Buffer.isBuffer(orig_data);
@@ -94,5 +96,4 @@ ECLibUtil.prototype.validateEncodeParams = function( ec_id, orig_data, deta_leng
 
 
 
-
 module.exports = ECLibUtil;
diff --git a/node-eclib.js b/node-eclib.js
index ba99368..8d047fb 100644
--- a/node-eclib.js
+++ b/node-eclib.js
@@ -1,124 +1,167 @@
-// Basic structures of the ECLib library
-
-// We will not require anything right now.
-//
-
 var addon = require('bindings')('Release/node-eclib.node')
 var ECLibUtil = require("./eclib-util.js");
 var enums = require("./eclib-enum.js");
 var __ = require('underscore');
 
-function ECLib(opts){
-	var d_options = {"bc_id":0,  //backend ID
-			 "k":8,      //number of data fragments
-			 "m":4,      //number of parity fragments
-			 "w":0,      //word size, in bits
-			 "hd":0,     //hamming distance (=m for Reed-Solomon)
-			 "ct":0 };   //fragment checksum type
+function ECLib(opts) {
+	var d_options = {
+		"bc_id": 0, //backend ID
+		"k": 8, //number of data fragments
+		"m": 4, //number of parity fragments
+		"w": 0, //word size, in bits
+		"hd": 0, //hamming distance (=m for Reed-Solomon)
+		"ct": 0
+	}; //fragment checksum type
 
 	this.opt = {};
-	__.extend(this.opt,d_options);
+	__.extend(this.opt, d_options);
 
-	if (__.size(opts) > 0){
-		__.extend(this.opt, opts );
+	if (__.size(opts) > 0) {
+		__.extend(this.opt, opts);
 	}
 
 	this.ins_id = null;
 	this.eclibUtil = new ECLibUtil();
-	this.isValidInstance = function(){
-
-		return ( __.isUndefined(this.ins_id));
-
+	this.isValidInstance = function() {
+		return (__.isUndefined(this.ins_id));
 	};
 
-	this.resetOptions = function(){
+	this.resetOptions = function() {
 		this.opt = null;
-		__.extend(this.opt,d_options);
+		__.extend(this.opt, d_options);
 	};
 }
 
 ECLib.prototype = {
-	
-	init: function(callback){
+
+	init: function(callback) {
 		//This will be the  create method of the ECLIB
 		var instance_descriptor_id = -1;
 		var err = {};
-		var o= this.opt;
-		if ( this.eclibUtil.validateInstanceCreateParams(o.bc_id, o.k, o.m, o.w, o.hd, o.ct)  ){
+		var o = this.opt;
+		if (this.eclibUtil.validateInstanceCreateParams(o.bc_id, o.k, o.m, o.w, o.hd,
+				o.ct)) {
 
 			instance_descriptor_id = addon.create(o.bc_id, o.k, o.m, o.w, o.hd, o.ct);
-			
-			if (instance_descriptor_id <=0 ){
-				err.errorcode =  instance_descriptor_id ;
+
+			if (instance_descriptor_id <= 0) {
+				err.errorcode = instance_descriptor_id;
 				err.message = this.eclibUtil.getErrorMessage(instance_descriptor_id);
-			}else {
-				this.ins_id =instance_descriptor_id;
+			} else {
+				this.ins_id = instance_descriptor_id;
 			}
 
 		} else {
-			err.errorcode =  enums.ErrorCode.EINVALIDPARAMS ;
+			err.errorcode = enums.ErrorCode.EINVALIDPARAMS;
 			err.message = this.eclibUtil.getErrorMessage(err.errorcode);
-			instance_descriptor_id = err.errorcode ;
+			instance_descriptor_id = err.errorcode;
 		}
 
-
-		if (!callback){
-
+		if (!callback) {
 			return instance_descriptor_id;
 		}
 
-		callback.call(this,instance_descriptor_id, err);
-
-
-
+		callback.call(this, instance_descriptor_id, err);
 	},
-	destroy: function(callback){
+	destroy: function(callback) {
 
-		var resultcode = enums.ErrorCode.EBACKENDNOTAVAIL; 
+		var resultcode = enums.ErrorCode.EBACKENDNOTAVAIL;
 		var err = {};
 
-		if (this.isValidInstance()){
+		if (this.isValidInstance()) {
 			resultcode = addon.destroy(this.ins_id);
-			if ( resultcode !== 0){
+			if (resultcode !== 0) {
 				err.errorcode = resultcode;
 				err.message = this.eclibUtil.getErrorMessage(resultcode);
 			}
-
 		} else {
-		
 			err.errorcode = resultcode;
 			err.message = this.eclibUtil.getErrorMessage(resultcode);
-		
 		}
 
-		if (!callback){
+		if (!callback) {
 			return resultcode;
 		}
 
-		callback.call(this,resultcode,err);
+		callback.call(this, resultcode, err);
 
 	},
 
-	encode: function(o_data,callback){
-	    var o = this.opt;
+	encode: function(o_data, callback) {
+		var o = this.opt;
 
-	    addon.encode(this.ins_id, o.k, o.m, o_data, o_data.length, callback);
+		addon.encode(this.ins_id, o.k, o.m, o_data, o_data.length, callback);
 	},
 
-	encodev: function(n_buf,buf_array,total_size,callback){
-	    var o = this.opt;
+	encodev: function(n_buf, buf_array, total_size, callback) {
+		var o = this.opt;
 
-	    addon.encodev(this.ins_id, o.k, o.m, n_buf, buf_array, total_size, callback);
+		addon.encodev(this.ins_id, o.k, o.m, n_buf, buf_array, total_size, callback);
 	},
 
-	decode:function(d_data,n_frags,frag_len,force_metadata_check,callback){
-	    addon.decode(this.ins_id, d_data, n_frags, frag_len, force_metadata_check, callback);
+	decode: function(d_data, n_frags, frag_len, force_metadata_check, callback) {
+		addon.decode(this.ins_id, d_data, n_frags, frag_len, force_metadata_check, callback);
 	},
 
-	getFragmentMetadata: function(fragment, fragment_metadata, callback){
+	reconstructFragment: function(avail_fragments, missing_fragment_id, callback) {
+		if (!avail_fragments.length) {
+			callback(new Error('invalid number of available fragments (must be > 0)'), null);
+			return;
+		}
+		addon.reconstructFragment(
+			this.ins_id,
+			avail_fragments,
+			avail_fragments.length,
+			avail_fragments[0].length,
+			missing_fragment_id,
+			callback
+		);
+	},
 
+	reconstruct: function(avail_fragments, missing_fragment_ids, callback) {
+		var self = this;
+
+		// If we sort the missing indexes, than we can safely insert each
+		// recoevered fragment when we have it. Example: we have 10 fragments,
+		// but the 3rd, 6th and 8th are missing. If the `missing_fragment_ids`
+		// is unsorted, like [8,6,3], then we have the following
+		// `avail_fragments`: [1,2,4,5,7,9,10]. If we first recover the 8th
+		// fragment, we don't where to insert it. But if we first recover the
+		// 3rd fragment, we know we can insert it at index 3, so that we then
+		// have the `avail_fragments` set to [1,2,3,4,5,7,9,10] when we recover
+		// the 6th fragment.
+		missing_fragment_ids.sort();
+
+		// Reconstruct one fragment with a Promise (instead of a callback).
+		var recf = function(fragments, id) {
+			return new Promise(function(yes, no) {
+				self.reconstructFragment(fragments, id, function(err, fragment) {
+					if (err) return no(err);
+					yes(fragment);
+				});
+			});
+		};
+
+		// Recover all missing fragments one by one.
+		var done = new Promise(function(yes, no) { yes(); });
+		missing_fragment_ids.forEach(function(id) {
+			done = done.then(function() {
+				return recf(avail_fragments, id).then(function(frag) {
+					avail_fragments.splice(id, 0, frag);
+				});
+			});
+		});
+
+		done.then(function() {
+			callback(null, avail_fragments);
+		}, function(err) {
+			callback(err, null);
+		});
+	},
 
-	}, 
+	getFragmentMetadata: function(fragment, fragment_metadata, callback) {
+		// TODO: what is this function supposed to do ?
+	},
 
 	setOptions: function(opts){
 		__.extend(this.opt,opts);
diff --git a/package.json b/package.json
index 084f7ec..20e1c55 100644
--- a/package.json
+++ b/package.json
@@ -13,6 +13,7 @@
     "url": "https://github.com/scality/node-ECLib.git"
   },
   "scripts": {
+    "preinstall": "make",
     "install": "node-gyp configure && node-gyp build"
   },
   "main": "index.js",
diff --git a/run_tests.bash b/run_tests.bash
new file mode 100755
index 0000000..39782e7
--- /dev/null
+++ b/run_tests.bash
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+for t in `ls test`; do
+  node test/$t
+  if [ $? != 0 ]; then
+    exit 1
+  fi
+done
diff --git a/src/cpp/asyncdecode.cpp b/src/cpp/asyncdecode.cpp
index 841af61..4671449 100644
--- a/src/cpp/asyncdecode.cpp
+++ b/src/cpp/asyncdecode.cpp
@@ -5,91 +5,71 @@
 
 using namespace v8;
 
-//#define DPRINTF(fmt,...) do { fprintf(stderr, fmt, ##__VA_ARGS__); } while (0)
-#define DPRINTF(fmt,...)
-
-struct DecodeData {
-  //input
-  int instance_descriptor_id;
-  char **fragments;
-  int n_frag;
-  int frag_len;
-  int force_metadata_check;
-  //result
-  int status;
-  char *out_data;
-  uint64_t out_data_len;
-  //free
-};
-
-#if 0
-static void DecodeFree(char *out_data, void *hint) {
-  DecodeData *data = reinterpret_cast<DecodeData*>(hint);
+class AsyncDecodeWorker : public NanAsyncWorker {
+public:
+  AsyncDecodeWorker(NanCallback *callback, int instance_descriptor_id, char **fragments, int n_frag, int frag_len, int force_metadata_check) :
+    NanAsyncWorker(callback),
+    _instance_descriptor_id(instance_descriptor_id),
+    _fragments(fragments),
+    _n_frag(n_frag),
+    _frag_len(frag_len),
+    _force_metadata_check(force_metadata_check) {
+    }
 
-  DPRINTF("FREE DECODE %p\n", data);
-  liberasurecode_decode_cleanup(data->instance_descriptor_id, data->out_data);
-  
-  delete data;
-}
-#endif
-
-class DecodeWorker : public NanAsyncWorker {
- public:
-  DecodeWorker(NanCallback *callback, DecodeData *data)
-    : NanAsyncWorker(callback), data(data) {}
-  ~DecodeWorker() {
-    for (int i = 0;i < data->n_frag;i++) {
-      delete data->fragments[i];
+  ~AsyncDecodeWorker() {
+    for (int i = 0;i < _n_frag;i++) {
+      delete _fragments[i];
     }
-    delete data->fragments;
-    delete data;
+    delete _fragments;
   }
 
-  // Executed inside the worker-thread.
-  // It is not safe to access V8, or V8 data structures
-  // here, so everything we need for input and output
-  // should go on `this`.
-  void Execute () {
-    DPRINTF("execute decode %p\n", data);
-    data->status = liberasurecode_decode(data->instance_descriptor_id, 
-					 data->fragments, data->n_frag, data->frag_len, 
-					 data->force_metadata_check,
-					 &data->out_data, &data->out_data_len);
-    DPRINTF("execute decode done %p\n", data);
+  void Execute() {
+    _status = liberasurecode_decode(_instance_descriptor_id,
+				       _fragments, _n_frag, _frag_len,
+				       _force_metadata_check,
+				       &_out_data, &_out_data_len);
+
+    if (_status != 0) {
+      SetErrorMessage("an error occured while decoding");
+    }
   }
 
-  // Executed when the async work is complete
-  // this function will be run inside the main event loop
-  // so it is safe to use V8 again
-  void HandleOKCallback () {
+  void HandleOKCallback() {
     NanScope();
 
-    DPRINTF("DECODE Callback %p\n", data);
-
-    if (0 == data->status) {
-    
     Handle<Value> argv[] = {
-      NanNew<Number>(data->status),
-      NanNewBufferHandle(data->out_data, data->out_data_len),//, DecodeFree, data),
-      NanNew<Number>(data->out_data_len)
+      NanNew<Number>(_status),
+      NanNewBufferHandle(_out_data, _out_data_len),
+      NanNew<Number>(_out_data_len)
     };
 
-    liberasurecode_decode_cleanup(data->instance_descriptor_id, data->out_data);
-    data->out_data = NULL;
-    
+
+    liberasurecode_decode_cleanup(_instance_descriptor_id, _out_data);
+
     callback->Call(3, argv);
-  } else {
-    
+  }
+
+  void HandleErrorCallback() {
+    NanScope();
+
     Handle<Value> argv[] = {
-      NanNew<Number>(data->status)
+      NanNew<Number>(_status)
     };
-    
-     callback->Call(1, argv);
-  }
-  }
 
- private:
-  DecodeData *data;
+    callback->Call(1, argv);
+  }
+private:
+  // Input data.
+  int _instance_descriptor_id;
+  char **_fragments;
+  int _n_frag;
+  int _frag_len;
+  int _force_metadata_check;
+
+  // Output data.
+  int _status;
+  char *_out_data;
+  uint64_t _out_data_len;
 };
 
 NAN_METHOD(EclDecode) {
@@ -100,23 +80,24 @@ NAN_METHOD(EclDecode) {
     NanReturnUndefined();
   }
 
-  DecodeData *data = new DecodeData;
-  DPRINTF("Dec data %p\n", data);
-  
-  data->instance_descriptor_id = args[0]->NumberValue();
-  Local<Object>fragments_array = args[1]->ToObject();
-  data->n_frag = args[2]->NumberValue();
-  data->fragments = new char*[data->n_frag];
-  data->frag_len = args[3]->NumberValue();
-  for (int i = 0;i < data->n_frag;i++) {
-    char *fragment = node::Buffer::Data(fragments_array->Get(i));
-    data->fragments[i] = new char[data->frag_len];
-    memcpy(data->fragments[i], fragment, data->frag_len);
+  int n_frag = args[2]->NumberValue();
+  int frag_len = args[3]->NumberValue();
+
+  Local<Object> fragments_array = args[1]->ToObject();
+  char **fragments = new char*[n_frag];
+  for (int i = 0; i < n_frag; i++) {
+    fragments[i] = new char[frag_len];
+    memcpy(fragments[i], node::Buffer::Data(fragments_array->Get(i)), frag_len);
   }
-  data->force_metadata_check = args[4]->NumberValue();
-  
-  NanCallback *callback = new NanCallback(args[5].As<Function>());
-  NanAsyncQueueWorker(new DecodeWorker(callback, data));
-    
+
+  NanAsyncQueueWorker(new AsyncDecodeWorker(
+    new NanCallback(args[5].As<Function>()),
+    args[0]->NumberValue(),
+    fragments,
+    n_frag,
+    frag_len,
+    args[4]->NumberValue()
+  ));
+
   NanReturnUndefined();
 }
diff --git a/src/cpp/asyncdecode.h b/src/cpp/asyncdecode.h
index e3947e4..e938847 100644
--- a/src/cpp/asyncdecode.h
+++ b/src/cpp/asyncdecode.h
@@ -1,7 +1,12 @@
+#ifndef SCALITY_EC_ASYNC_DECODE_H
+
+#define SCALITY_EC_ASYNC_DECODE_H
+
 #include <node.h>
 #include <nan.h>
-
-#include <erasurecode.h>
-#include <erasurecode_helpers.h>
+#include <liberasurecode/erasurecode.h>
+#include <liberasurecode/erasurecode_helpers.h>
 
 NAN_METHOD(EclDecode);
+
+#endif
diff --git a/src/cpp/asyncencode.cpp b/src/cpp/asyncencode.cpp
index 91dacc2..5725411 100644
--- a/src/cpp/asyncencode.cpp
+++ b/src/cpp/asyncencode.cpp
@@ -5,135 +5,112 @@
 
 using namespace v8;
 
-//#define DPRINTF(fmt,...) do { fprintf(stderr, fmt, ##__VA_ARGS__); } while (0)
-#define DPRINTF(fmt,...)
-
-struct EncodeData {
-  //input
-  int instance_descriptor_id;
-  int k;
-  int m;
-  char *orig_data;
-  int orig_data_size;
-  //result
-  int status;
-  char **encoded_data;
-  char **encoded_parity;
-  uint64_t encoded_fragment_len;
-  //free
-  int count;
-};
+class AsyncEncodeWorker : public NanAsyncWorker {
+public:
+  AsyncEncodeWorker(NanCallback *callback, int instance_descriptor_id, int k, int m, char *orig_data, int orig_data_size) :
+    NanAsyncWorker(callback),
+    _instance_descriptor_id(instance_descriptor_id),
+    _k(k),
+    _m(m),
+    _orig_data(orig_data),
+    _orig_data_size(orig_data_size) {}
+
+  ~AsyncEncodeWorker() {
+    delete _orig_data;
+  }
+
+  void Execute() {
+    _status = liberasurecode_encode(_instance_descriptor_id,
+                 _orig_data, _orig_data_size,
+                 &_encoded_data,
+                 &_encoded_parity,
+                 &_encoded_fragment_len);
 
-#if 0
-static void EncodeFree(char *out_data, void *hint) {
-    EncodeData *data = reinterpret_cast<EncodeData*>(hint);
-    DPRINTF("FREE ENCODE TMP %d %p\n", data->count, data);
-    data->count--;
-
-    if (0 == data->count) {
-      DPRINTF("FREE ENCODE %p\n", data);
-      liberasurecode_encode_cleanup(data->instance_descriptor_id,
-				    data->encoded_data,
-				    data->encoded_parity);
-      delete data;
+    if (_status != 0) {
+      SetErrorMessage("an error occured while encoding");
     }
-}
-#endif
-
-class EncodeWorker : public NanAsyncWorker {
- public:
-  EncodeWorker(NanCallback *callback, EncodeData *data)
-    : NanAsyncWorker(callback), data(data) {}
-  ~EncodeWorker() {
-    delete data->orig_data;
-    delete data;
   }
 
-  // Executed inside the worker-thread.
-  // It is not safe to access V8, or V8 data structures
-  // here, so everything we need for input and output
-  // should go on `this`.
-  void Execute () {
-    DPRINTF("Encoding %p\n", data);
-    data->status = liberasurecode_encode(data->instance_descriptor_id,
-					 data->orig_data, data->orig_data_size,
-					 &data->encoded_data, 
-					 &data->encoded_parity, 
-					 &data->encoded_fragment_len);
-    DPRINTF("Encoding Done %p\n", data);
+  void HandleOKCallback() {
+    NanScope();
+
+    Handle<Array> encoded_data_array = NanNew<Array>(_k);
+    for (int i = 0; i < _k; i++) {
+      encoded_data_array->Set(i, NanNewBufferHandle(_encoded_data[i], _encoded_fragment_len));
+    }
+
+    Handle<Array> encoded_parity_array = NanNew<Array>(_m);
+    for (int i = 0; i < _m; i++) {
+      encoded_parity_array->Set(i, NanNewBufferHandle(_encoded_parity[i], _encoded_fragment_len));
+    }
+
+    liberasurecode_encode_cleanup(_instance_descriptor_id,
+          _encoded_data,
+          _encoded_parity);
+
+    Handle<Value> argv[] = {
+      NanNew<Number>(_status),
+      encoded_data_array,
+      encoded_parity_array,
+      NanNew<Number>(_encoded_fragment_len)
+    };
+
+    callback->Call(4, argv);
   }
 
-  // Executed when the async work is complete
-  // this function will be run inside the main event loop
-  // so it is safe to use V8 again
-  void HandleOKCallback () {
+  void HandleErrorCallback() {
     NanScope();
 
-    if (0 == data->status) {
-      DPRINTF("Encoding OK CB %p\n", data);
-      data->count = data->k + data->m;
-
-      Handle<Array> encoded_data_array = NanNew<Array>(data->k);
-      for (int i = 0; i < data->k;i++) {
-	encoded_data_array->Set(i, NanNewBufferHandle(data->encoded_data[i], data->encoded_fragment_len));//, EncodeFree, data));
-      }
-
-      Handle<Array> encoded_parity_array = NanNew<Array>(data->m);
-      for (int i = 0; i < data->m;i++) {
-	encoded_parity_array->Set(i, NanNewBufferHandle(data->encoded_parity[i], data->encoded_fragment_len));//, EncodeFree, data));
-      }
-
-      Handle<Value> argv[] = {
-	NanNew<Number>(data->status),
-	encoded_data_array,
-	encoded_parity_array,
-	NanNew<Number>(data->encoded_fragment_len)
-      };
-
-      liberasurecode_encode_cleanup(data->instance_descriptor_id,
-				    data->encoded_data,
-				    data->encoded_parity);
-      data->encoded_data = NULL;
-      data->encoded_parity = NULL;
-    
-      callback->Call(4, argv);
-  } else {
-    
     Handle<Value> argv[] = {
-      NanNew<Number>(data->status)
+      NanNew<Number>(_status)
     };
-    
+
     callback->Call(1, argv);
-    }
   }
 
- private:
-  EncodeData *data;
+private:
+  // Input data.
+  int _instance_descriptor_id;
+  int _k;
+  int _m;
+  char *_orig_data;
+  int _orig_data_size;
+  // Output data.
+  int _status;
+  char **_encoded_data;
+  char **_encoded_parity;
+  uint64_t _encoded_fragment_len;
 };
 
-
 NAN_METHOD(EclEncode) {
   NanScope();
 
   if (args.Length() < 6) {
-    NanThrowTypeError("Wrong number of arguments desc_id k m buf size cb");
+    char msg[1024];
+    sprintf(msg, "Wrong number of arguments (expected 6, got %d)", args.Length());
+    NanThrowTypeError(msg);
     NanReturnUndefined();
   }
 
-  EncodeData *data = new EncodeData;
-  DPRINTF("Enc data %p\n", data);
-
-  data->instance_descriptor_id = args[0]->NumberValue();
-  data->k = args[1]->NumberValue();
-  data->m = args[2]->NumberValue();
-  data->orig_data_size = args[4]->NumberValue();
+  int instance_descriptor_id = args[0]->NumberValue();
+  int k = args[1]->NumberValue();
+  int m = args[2]->NumberValue();
+  int orig_data_size = args[4]->NumberValue();
   char *orig_data = node::Buffer::Data(args[3]);
-  data->orig_data = new char[data->orig_data_size];
-  memcpy(data->orig_data, orig_data, data->orig_data_size);
+  char *pass_orig_data = new char[orig_data_size];
+  memcpy(pass_orig_data, orig_data, orig_data_size);
 
   NanCallback *callback = new NanCallback(args[5].As<Function>());
 
-  NanAsyncQueueWorker(new EncodeWorker(callback, data));
+  NanAsyncQueueWorker(new AsyncEncodeWorker(
+    callback,
+    instance_descriptor_id,
+    k,
+    m,
+    pass_orig_data,
+    orig_data_size
+  ));
+
   NanReturnUndefined();
 }
 
@@ -141,32 +118,38 @@ NAN_METHOD(EclEncodeV) {
   NanScope();
 
   if (args.Length() < 7) {
-    NanThrowTypeError("Wrong number of arguments desc_id k m n_buf buf_array total_size cb");
+    char msg[1024];
+    sprintf(msg, "Wrong number of arguments (expected 7, got %d)", args.Length());
+    NanThrowTypeError(msg);
     NanReturnUndefined();
   }
 
-  EncodeData *data = new EncodeData;
-  DPRINTF("Enc data %p\n", data);
-
-  data->instance_descriptor_id = args[0]->NumberValue();
-  data->k = args[1]->NumberValue();
-  data->m = args[2]->NumberValue();
+  int instance_descriptor_id = args[0]->NumberValue();
+  int k = args[1]->NumberValue();
+  int m = args[2]->NumberValue();
 
-  data->orig_data_size = args[5]->NumberValue();
-  data->orig_data = new char[data->orig_data_size];
+  int orig_data_size = args[5]->NumberValue();
+  char *orig_data = new char[orig_data_size];
 
   Local<Object>buf_array = args[4]->ToObject();
   int n_buf = args[3]->NumberValue();
   int off = 0;
-  for (int i = 0;i < n_buf;i++) {
+  for (int i = 0; i < n_buf; i++) {
     char *buf = node::Buffer::Data(buf_array->Get(i));
     int buf_len = node::Buffer::Length(buf_array->Get(i));
-    memcpy(data->orig_data + off, buf, buf_len);
+    memcpy(orig_data + off, buf, buf_len);
     off += buf_len;
   }
 
   NanCallback *callback = new NanCallback(args[6].As<Function>());
 
-  NanAsyncQueueWorker(new EncodeWorker(callback, data));
+  NanAsyncQueueWorker(new AsyncEncodeWorker(
+    callback,
+    instance_descriptor_id,
+    k,
+    m,
+    orig_data,
+    orig_data_size
+  ));
   NanReturnUndefined();
 }
diff --git a/src/cpp/asyncencode.h b/src/cpp/asyncencode.h
index 34eeda9..ca71023 100644
--- a/src/cpp/asyncencode.h
+++ b/src/cpp/asyncencode.h
@@ -1,10 +1,13 @@
-#include <node.h>
-#include <nan.h>
-
+#ifndef SCALITY_EC_ASYNC_ENCODE_H
 
-#include <erasurecode.h>
-#include <erasurecode_helpers.h>
+#define SCALITY_EC_ASYNC_ENCODE_H
 
+#include <node.h>
+#include <nan.h>
+#include <liberasurecode/erasurecode.h>
+#include <liberasurecode/erasurecode_helpers.h>
 
 NAN_METHOD(EclEncode);
 NAN_METHOD(EclEncodeV);
+
+#endif
diff --git a/src/cpp/asyncreconstruction.cpp b/src/cpp/asyncreconstruction.cpp
index ec40fe6..3548e4e 100644
--- a/src/cpp/asyncreconstruction.cpp
+++ b/src/cpp/asyncreconstruction.cpp
@@ -1,12 +1,103 @@
-#include <node.h>
-#include <nan.h>
-#include <erasurecode.h>
-#include <erasurecode_helpers.h>
-
 #include "asyncreconstruction.h"
 
+using namespace v8;
+
+class AsyncReconstructWorker : public NanAsyncWorker {
+public:
+    AsyncReconstructWorker(
+        int instance_descriptor_id,
+        char **avail_fragments_ptr,
+        int num_fragments,
+        int fragment_length,
+        int missing_fragment_id,
+        NanCallback *callback):
+            NanAsyncWorker(callback),
+            _status(-1),
+            _instance_descriptor_id(instance_descriptor_id),
+            _avail_fragments_ptr(avail_fragments_ptr),
+            _num_fragments(num_fragments),
+            _fragment_length(fragment_length),
+            _missing_fragment_id(missing_fragment_id) {
+        _reconstructed_fragment = new char[_fragment_length];
+    }
+
+    ~AsyncReconstructWorker() {
+        for (int i = 0; i < _num_fragments; i++) {
+            delete _avail_fragments_ptr[i];
+        }
+        delete _avail_fragments_ptr;
+        delete _reconstructed_fragment;
+    }
+
+    void Execute() {
+        _status = liberasurecode_reconstruct_fragment(
+            _instance_descriptor_id,
+            _avail_fragments_ptr,
+            _num_fragments,
+            _fragment_length,
+            _missing_fragment_id,
+            _reconstructed_fragment
+        );
+
+        if (_status != 0) {
+            SetErrorMessage("an error occured while reconstructing");
+        }
+    }
+
+    void HandleOKCallback() {
+        NanScope();
+
+        Handle<Value> argv[] = {
+            NanNull(),
+            NanNewBufferHandle(_reconstructed_fragment, _fragment_length)
+        };
+
+        callback->Call(2, argv);
+    }
+
+    void HandleErrorCallback() {
+        NanScope();
+
+        Handle<Value> argv[] = {
+            NanError("could not reconstruct fragment")
+        };
+
+        callback->Call(1, argv);
+    }
+
+private:
+    int _status;
+    int _instance_descriptor_id;
+    char **_avail_fragments_ptr;
+    int _num_fragments;
+    int _fragment_length;
+    int _missing_fragment_id;
+    char *_reconstructed_fragment;
+};
+
 NAN_METHOD(EclReconstructFragment) {
-  NanScope();
+    NanScope();
+
+    int instance_descriptor_id = args[0]->NumberValue();
+    int num_fragments = args[2]->NumberValue();
+    int fragment_length = args[3]->NumberValue();
+    int missing_fragment_id = args[4]->NumberValue();
+    Local<Object> avail_fragments = args[1]->ToObject();
+    char **avail_fragments_ptr = new char*[num_fragments];
+    for (int i = 0; i < num_fragments; i++) {
+        avail_fragments_ptr[i] = new char[fragment_length];
+        memcpy(avail_fragments_ptr[i], node::Buffer::Data(avail_fragments->Get(i)), fragment_length);
+    }
+
+    NanCallback *callback = new NanCallback(args[5].As<Function>());
 
-  NanReturnValue(NanNew("C++ Reconstruct Fragment"));
+    NanAsyncQueueWorker(new AsyncReconstructWorker(
+        instance_descriptor_id,
+        avail_fragments_ptr,
+        num_fragments,
+        fragment_length,
+        missing_fragment_id,
+        callback
+    ));
+    NanReturnUndefined();
 }
diff --git a/src/cpp/asyncreconstruction.h b/src/cpp/asyncreconstruction.h
index 3334635..c186a88 100644
--- a/src/cpp/asyncreconstruction.h
+++ b/src/cpp/asyncreconstruction.h
@@ -1,7 +1,12 @@
+#ifndef SCALITY_EC_ASYNC_RECONSTRUCTION_H
+
+#define SCALITY_EC_ASYNC_RECONSTRUCTION_H
+
 #include <node.h>
 #include <nan.h>
-#include <erasurecode.h>
-#include <erasurecode_helpers.h>
+#include <liberasurecode/erasurecode.h>
+#include <liberasurecode/erasurecode_helpers.h>
 
 NAN_METHOD(EclReconstructFragment);
 
+#endif
diff --git a/src/cpp/libmain.cpp b/src/cpp/libmain.cpp
index 952a561..083691d 100644
--- a/src/cpp/libmain.cpp
+++ b/src/cpp/libmain.cpp
@@ -26,11 +26,9 @@ NAN_METHOD(EclCreate) {
   int hd = args[4]->NumberValue();
   int _ct = args[5]->NumberValue();
 
-  //printf("id=%d k=%d m=%d w=%d hd=%d ct=%d\n", _id, k, m, w, hd, _ct);
-
   ec_backend_id = get_ec_backend_id(_id);
   ct  = get_ec_checksum_type(_ct);
-  
+
   memset(&ec_args, 0, sizeof (ec_args));
   ec_args.k = k;
   ec_args.m = m;
@@ -44,12 +42,11 @@ NAN_METHOD(EclCreate) {
     NanThrowTypeError("Liberasurecode initialization failed");
     NanReturnUndefined();
   }
-  
-  NanReturnValue( NanNew(desc));
+
+  NanReturnValue(NanNew(desc));
 }
 
 NAN_METHOD(EclDestroy) {
-  
   NanScope();
 
   int arg0 = args[0]->NumberValue();
diff --git a/src/cpp/libmain.h b/src/cpp/libmain.h
index fffb8a1..aae561e 100644
--- a/src/cpp/libmain.h
+++ b/src/cpp/libmain.h
@@ -1,7 +1,7 @@
 #include <node.h>
 #include <nan.h>
-#include <erasurecode.h>
-#include <erasurecode_helpers.h>
+#include <liberasurecode/erasurecode.h>
+#include <liberasurecode/erasurecode_helpers.h>
 
 
 NAN_METHOD(EclCreate);
@@ -13,5 +13,3 @@ NAN_METHOD(EclVerifyStripeMetadata);
 NAN_METHOD(EclGetAlignedDataSize);
 NAN_METHOD(EclGetMinimumEncodeSize);
 NAN_METHOD(EclGetFragmentSize);
-NAN_METHOD(testpad);
-
diff --git a/src/cpp/libutil.cpp b/src/cpp/libutil.cpp
index 2c5c578..23e7b36 100644
--- a/src/cpp/libutil.cpp
+++ b/src/cpp/libutil.cpp
@@ -6,14 +6,14 @@ ec_args * el_create_ec_args(int k, int m, int w, int hd, ec_checksum_type_t ct){
 
     ec_args *result;
     result = (ec_args*)malloc( sizeof( ec_args ) );
-    
+
     if(!result){
 
         result->k = k;
         result->m = m;
         result->w = w;
         result->hd = hd;
-        result->ct;
+        result->ct = ct;
     }
 
     return result;
@@ -75,5 +75,3 @@ ec_checksum_type_t get_ec_checksum_type(int ct){
     }
 
 }
-
-
diff --git a/src/cpp/libutil.h b/src/cpp/libutil.h
index 63a4dbd..cbda10a 100644
--- a/src/cpp/libutil.h
+++ b/src/cpp/libutil.h
@@ -1,9 +1,12 @@
-#include <erasurecode.h>
-#include <erasurecode_helpers.h>
+#ifndef SCALITY_EC_LIBUTIL_H
 
+#define SCALITY_EC_LIBUTIL_H
+
+#include <liberasurecode/erasurecode.h>
+#include <liberasurecode/erasurecode_helpers.h>
 
 ec_args * el_create_ec_args(int k, int m, int w, int hd, ec_checksum_type_t ct);
 ec_backend_id_t get_ec_backend_id(int id);
 ec_checksum_type_t get_ec_checksum_type(int ct);
 
-
+#endif
diff --git a/src/cpp/linmain.h b/src/cpp/linmain.h
new file mode 100644
index 0000000..bdd73e7
--- /dev/null
+++ b/src/cpp/linmain.h
@@ -0,0 +1,5 @@
+#ifndef SCALITY_EC_LIBMAIN_H
+
+#define SCALITY_EC_LIBMAIN_H
+
+#endif
diff --git a/src/cpp/node-eclib.cpp b/src/cpp/node-eclib.cpp
index c2afe54..645e793 100644
--- a/src/cpp/node-eclib.cpp
+++ b/src/cpp/node-eclib.cpp
@@ -55,4 +55,3 @@ void InitAll(Handle<Object> exports) {
 }
 
 NODE_MODULE(node_eclib, InitAll)
-
diff --git a/test/encodev.js b/test/encodev.js
index 4c118ba..6b06684 100644
--- a/test/encodev.js
+++ b/test/encodev.js
@@ -1,70 +1,62 @@
 // test encodev
 
+'use strict';
+
 var ECLib = require('../node-eclib.js');
 var enums = require('../eclib-enum.js');
 var ECLibUtil = require('../eclib-util.js');
 var buffertools = require("buffertools");
 var crypto = require('crypto');
 var hexdump = require('hexdump-nodejs');
-
-console.log("ECLib testing");
+var assert = require('assert');
 
 function test_one(name, opts) {
-    console.log("create " + name);
-
-    var eclib = new ECLib(opts);
-    
-    eclib.init();
-    
-    var sz1 = 123434;
-    var sz2 = 343434;
-    var ref_buf1 = crypto.randomBytes(sz1);
-    var ref_buf2 = crypto.randomBytes(sz2);
-    var ref_buf = buffertools.concat(ref_buf1, ref_buf2);
-    var buf_array = [ref_buf1, ref_buf2];
-
-    eclib.encodev(2, buf_array, sz1 + sz2,
-		 function(status, encoded_data, encoded_parity, encoded_fragment_length) {
-		     console.log(name + " Encode Done status=" + status + " fragment_length=" + encoded_fragment_length);
-		     
-		     k = eclib.opt.k;
-		     m = eclib.opt.m;
-		     
-		     x = k-1; //available data fragments
-		     y = m;   //available parity fragments
-		     
-		     var fragments = [];
-		     var i, j;
-		     j = 0;
-		     //console.log('data:');
-		     for (i = 0;i < x;i++) {
-			 //console.log(hexdump(encoded_data[i]));
-			 fragments[j++] = encoded_data[i];
-		     }
-		     //console.log('codings:');
-		     for (i = 0;i < y;i++) {
-			 //console.log(hexdump(encoded_parity[i]));
-			 fragments[j++] = encoded_parity[i];
-		     }
-		     
-		     eclib.decode(fragments, x+y, encoded_fragment_length, 0,
-				  function(status, out_data, out_data_length) {
-				      console.log(name + " Decode Done status=" + status + " data_length=" + out_data_length);
-
-				      //console.log(hexdump(out_data));
-				      
-				      if (buffertools.compare(out_data, ref_buf) == 0)
-					  console.log(name + " OK Buffers are identical");
-				      else
-					  console.log(name + " Nok buffers differ");
-				      eclib.destroy();
-				      delete ref_buf;
-				  }
-				 );
-		 }
-		);
+  var eclib = new ECLib(opts);
+  eclib.init();
+
+  var sz1 = 123434;
+  var sz2 = 343434;
+  var ref_buf1 = crypto.randomBytes(sz1);
+  var ref_buf2 = crypto.randomBytes(sz2);
+  var ref_buf = buffertools.concat(ref_buf1, ref_buf2);
+  var buf_array = [ref_buf1, ref_buf2];
+
+  process.stdout.write('.');
+
+  eclib.encodev(2, buf_array, sz1 + sz2,
+    function(status, encoded_data, encoded_parity, encoded_fragment_length) {
+      var k = eclib.opt.k;
+      var m = eclib.opt.m;
+
+      var x = k - 1; //available data fragments
+      var y = m; //available parity fragments
+
+      var fragments = [];
+      var i, j = 0;
+      for (i = 0; i < x; i++) {
+        fragments[j++] = encoded_data[i];
+      }
+      for (i = 0; i < y; i++) {
+        fragments[j++] = encoded_parity[i];
+      }
+
+      process.stdout.write('.');
+
+      eclib.decode(fragments, x + y, encoded_fragment_length, 0,
+        function(status, out_data, out_data_length) {
+          assert.equal(buffertools.compare(out_data, ref_buf), 0);
+          eclib.destroy();
+          console.log(' done');
+        }
+      );
+    }
+  );
 }
 
-//console.log(hexdump(ref_buf));
-
-test_one("xor", {"bc_id": enums.BackendId["EC_BACKEND_FLAT_XOR_HD"], "k": 3, "m": 3, "hd": 3});
+process.stdout.write('encodev: ');
+test_one("xor", {
+  "bc_id": enums.BackendId["EC_BACKEND_FLAT_XOR_HD"],
+  "k": 3,
+  "m": 3,
+  "hd": 3
+});
diff --git a/test/freetest.js b/test/freetest.js
index 32587f1..0320457 100644
--- a/test/freetest.js
+++ b/test/freetest.js
@@ -1,71 +1,53 @@
 // test that liberasure code buffers are cleaned up
 
+'use strict';
+
 var ECLib = require('../node-eclib.js');
 var enums = require('../eclib-enum.js');
 var ECLibUtil = require('../eclib-util.js');
 var buffertools = require("buffertools");
 var crypto = require('crypto');
 var hexdump = require('hexdump-nodejs');
+var assert = require('assert');
 
-console.log("ECLib testing");
+function decode_result(status, out_data, out_data_length) {
+  // Buffers must be equal, or else something bad happened.
+  assert.equal(buffertools.compare(out_data, ref_buf), 0);
 
-var done = false;
+  // Free memory used by ECLib.
+  eclib.destroy();
 
-function set_done_true() {
-    done = true;
+  console.log(' done');
 }
 
-function decode_result(status, out_data, out_data_length) {
-    console.log("Decode Done status=" + status + " data_length=" + out_data_length);
-    
-    //console.log(hexdump(out_data));
+function encode_result(status, encoded_data, encoded_parity,
+  encoded_fragment_length) {
 
-    console.log("comparing");
-    if (buffertools.compare(out_data, ref_buf) == 0)
-	console.log("OK Buffers are identical");
-    else
-	console.log("Nok buffers differ");
+  var k = eclib.opt.k;
+  var m = eclib.opt.m;
 
-    setTimeout(set_done_true, 500);
-}
+  var x = k - 1; //available data fragments
+  var y = m; //available parity fragments
 
-function encode_result(status, encoded_data, encoded_parity, encoded_fragment_length) {
-    console.log("Encode Done status=" + status + " fragment_length=" + encoded_fragment_length);
-    
-    k = eclib.opt.k;
-    m = eclib.opt.m;
-    
-    x = k-1; //available data fragments
-    y = m;   //available parity fragments
-    
-    var fragments = [];
-    var i, j;
-    j = 0;
-    //console.log('data:');
-    for (i = 0;i < x;i++) {
-	//console.log(hexdump(encoded_data[i]));
-	fragments[j++] = encoded_data[i];
-    }
-    //console.log('codings:');
-    for (i = 0;i < y;i++) {
-	//console.log(hexdump(encoded_parity[i]));
-	fragments[j++] = encoded_parity[i];
-    }
-    
-    console.log("decode");
-    eclib.decode(fragments, x+y, encoded_fragment_length, 0, decode_result);
-    console.log("decode started in bg");
-}
+  var fragments = [];
+  var i, j;
+  j = 0;
+  for (i = 0; i < x; i++) {
+    fragments[j++] = encoded_data[i];
+  }
+  //console.log('codings:');
+  for (i = 0; i < y; i++) {
+    fragments[j++] = encoded_parity[i];
+  }
 
-function test_one() {
+  process.stdout.write('.');
 
-    //ref_buf = new Buffer(10000);
-    //buffertools.fill(ref_buf, 'z');
-    //console.log(hexdump(ref_buf));
+  eclib.decode(fragments, x + y, encoded_fragment_length, 0, decode_result);
+}
 
-    console.log("encode");
-    eclib.encode(ref_buf, encode_result);
-    console.log("encode started in bg");
+function test_one() {
+  process.stdout.write('.');
+  eclib.encode(ref_buf, encode_result);
 }
 
 //EC_BACKEND_NULL
@@ -76,32 +58,14 @@ function test_one() {
 //EC_BACKEND_SHSS
 
 var eclib = new ECLib({
-    "bc_id": enums.BackendId["EC_BACKEND_FLAT_XOR_HD"],
-    "k": 3,
-    "m": 3,
-    "hd": 3
+  "bc_id": enums.BackendId["EC_BACKEND_FLAT_XOR_HD"],
+  "k": 3,
+  "m": 3,
+  "hd": 3
 });
+eclib.init();
 
-eclib.init()
-
-//eclib.testpad();
-
-//ref_buf = new Buffer(1000000000);
-//buffertools.fill(ref_buf, 'z');
-ref_buf = crypto.randomBytes(100000);
+var ref_buf = crypto.randomBytes(100000);
 
+process.stdout.write('free: ');
 test_one();
-
-var i = 0;
-var work = function(dosomestuff) {
-    console.log("dosomestuff in JS "+ (i++));
-    if (!done) {
-        process.nextTick(work);
-    } else {
-	console.log("DONE");
-	delete ref_buf;
-	eclib.destroy();
-	global.gc(); //requires --expose-gc
-    }
-}
-work();
diff --git a/test/functest.js b/test/functest.js
index b7a9e9d..82fcb64 100644
--- a/test/functest.js
+++ b/test/functest.js
@@ -1,66 +1,64 @@
 // launch multiple encodes/decodes in parallel
 
+'use strict';
+
 var ECLib = require('../node-eclib.js');
 var enums = require('../eclib-enum.js');
 var ECLibUtil = require('../eclib-util.js');
 var buffertools = require("buffertools");
 var crypto = require('crypto');
 var hexdump = require('hexdump-nodejs');
+var assert = require('assert');
 
-console.log("ECLib testing");
+// Number of tests that are done at any given time.
+var done = 0;
 
 function test_one(name, opts) {
-    console.log("create " + name);
-
-    var eclib = new ECLib(opts);
-    
-    eclib.init();
-    
-    var ref_buf = crypto.randomBytes(10000000);
-
-    eclib.encode(ref_buf,
-		 function(status, encoded_data, encoded_parity, encoded_fragment_length) {
-		     console.log(name + " Encode Done status=" + status + " fragment_length=" + encoded_fragment_length);
-		     
-		     k = eclib.opt.k;
-		     m = eclib.opt.m;
-		     
-		     x = k-1; //available data fragments
-		     y = m;   //available parity fragments
-		     
-		     var fragments = [];
-		     var i, j;
-		     j = 0;
-		     //console.log('data:');
-		     for (i = 0;i < x;i++) {
-			 //console.log(hexdump(encoded_data[i]));
-			 fragments[j++] = encoded_data[i];
-		     }
-		     //console.log('codings:');
-		     for (i = 0;i < y;i++) {
-			 //console.log(hexdump(encoded_parity[i]));
-			 fragments[j++] = encoded_parity[i];
-		     }
-		     
-		     eclib.decode(fragments, x+y, encoded_fragment_length, 0,
-				  function(status, out_data, out_data_length) {
-				      console.log(name + " Decode Done status=" + status + " data_length=" + out_data_length);
-
-				      //console.log(hexdump(out_data));
-				      
-				      if (buffertools.compare(out_data, ref_buf) == 0)
-					  console.log(name + " OK Buffers are identical");
-				      else
-					  console.log(name + " Nok buffers differ");
-				      eclib.destroy();
-				      delete ref_buf;
-				  }
-				 );
-		 }
-		);
-}
+  var eclib = new ECLib(opts);
+
+  eclib.init();
+
+  var ref_buf = crypto.randomBytes(10000000);
+
+  process.stdout.write('.');
+
+  eclib.encode(ref_buf,
+    function(status, encoded_data, encoded_parity, encoded_fragment_length) {
+
+      var k = eclib.opt.k;
+      var m = eclib.opt.m;
+
+      var x = k - 1; //available data fragments
+      var y = m; //available parity fragments
+
+      var fragments = [];
+      var i, j;
+      j = 0;
+      for (i = 0; i < x; i++) {
+        fragments[j++] = encoded_data[i];
+      }
+      for (i = 0; i < y; i++) {
+        fragments[j++] = encoded_parity[i];
+      }
+
+      process.stdout.write('.');
 
-//console.log(hexdump(ref_buf));
+      eclib.decode(fragments, x + y, encoded_fragment_length, 0,
+        function(status, out_data, out_data_length) {
+          // If buffers are not equal, something bad must have happened.
+          assert.equal(buffertools.compare(out_data, ref_buf), 0);
+
+          // Free the ressources allocated for erasure coding.
+          eclib.destroy();
+
+          // Node is single threaded so this is safe to do.
+          done += 1;
+          process.stdout.write('.');
+        }
+      );
+    }
+  );
+}
 
 //EC_BACKEND_NULL
 //EC_BACKEND_JERASURE_RS_VAND
@@ -70,16 +68,107 @@ function test_one(name, opts) {
 //EC_BACKEND_SHSS
 //EC_BACKEND_ISA_L_RS_CAUCHY
 
+// TODO: why is this off ?
 //test_one("null", {"bc_id": enums.BackendId["EC_BACKEND_NULL"], "k": 8, "m": 4});
-test_one("xor", {"bc_id": enums.BackendId["EC_BACKEND_FLAT_XOR_HD"], "k": 3, "m": 3, "hd": 3});
-test_one("vand", {"bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_VAND"], "k": 10, "m": 4, "w": 16, "hd": 5});
-test_one("vand_44", {"bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_VAND"], "k": 4, "m": 4, "w": 16, "hd": 5});
-test_one("vand_48", {"bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_VAND"], "k": 4, "m": 8, "w": 16, "hd": 9});
-test_one("vand_1010", {"bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_VAND"], "k": 10, "m": 10, "w": 16, "hd": 11});
-test_one("cauchy", {"bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"], "k": 10, "m": 4, "w": 4, "hd": 5});
-test_one("cauchy_44", {"bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"], "k": 4, "m": 4, "w": 4, "hd": 5});
-test_one("cauchy_48", {"bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"], "k": 4, "m": 8, "w": 8, "hd": 9});
-test_one("cauchy_1010", {"bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"], "k": 10, "m": 10, "w": 8, "hd": 11});
-test_one("isa_l", {"bc_id": enums.BackendId["EC_BACKEND_ISA_L_RS_VAND"], "k": 10, "m": 4, "w": 8, "hd": 5});
-test_one("isa_l_44", {"bc_id": enums.BackendId["EC_BACKEND_ISA_L_RS_VAND"], "k": 4, "m": 4, "w": 8, "hd": 5});
-test_one("isa_l_1010", {"bc_id": enums.BackendId["EC_BACKEND_ISA_L_RS_VAND"], "k": 10, "m": 10, "w": 8, "hd": 11});
+
+var tests = [{
+  name: "xor",
+  options: {
+    "bc_id": enums.BackendId["EC_BACKEND_FLAT_XOR_HD"],
+    "k": 3,
+    "m": 3,
+    "hd": 3
+  },
+}, {
+  name: "vand",
+  options: {
+    "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_VAND"],
+    "k": 10,
+    "m": 4,
+    "w": 16,
+    "hd": 5
+  }
+}, {
+  name: "vand_44",
+  options: {
+    "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_VAND"],
+    "k": 4,
+    "m": 4,
+    "w": 16,
+    "hd": 5
+  }
+}, {
+  name: "vand_48",
+  options: {
+    "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_VAND"],
+    "k": 4,
+    "m": 8,
+    "w": 16,
+    "hd": 9
+  }
+}, {
+  name: "vand_1010",
+  options: {
+    "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_VAND"],
+    "k": 10,
+    "m": 10,
+    "w": 16,
+    "hd": 11
+  }
+}, {
+  name: "cauchy",
+  options: {
+    "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"],
+    "k": 10,
+    "m": 4,
+    "w": 4,
+    "hd": 5
+  }
+}, {
+  name: "cauchy_44",
+  options: {
+    "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"],
+    "k": 4,
+    "m": 4,
+    "w": 4,
+    "hd": 5
+  }
+}, {
+  name: "cauchy_48",
+  options: {
+    "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"],
+    "k": 4,
+    "m": 8,
+    "w": 8,
+    "hd": 9
+  }
+}, {
+  name: "cauchy_1010",
+  options: {
+    "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"],
+    "k": 10,
+    "m": 10,
+    "w": 8,
+    "hd": 11
+  }
+}];
+
+function monitorState() {
+  if (done < tests.length) {
+    setImmediate(monitorState);
+  } else {
+    console.log(' done');
+  }
+}
+monitorState();
+
+process.stdout.write('algorithms: ');
+tests.forEach(function(test, i) {
+  test_one(test.name, test.options);
+})
+
+// The tests with ISA require an additional library. They are disabled for now because of this.
+
+// test_one("isa_l", {"bc_id": enums.BackendId["EC_BACKEND_ISA_L_RS_VAND"], "k": 10, "m": 4, "w": 8, "hd": 5});
+// test_one("isa_l_44", {"bc_id": enums.BackendId["EC_BACKEND_ISA_L_RS_VAND"], "k": 4, "m": 4, "w": 8, "hd": 5});
+// test_one("isa_l_1010", {"bc_id": enums.BackendId["EC_BACKEND_ISA_L_RS_VAND"], "k": 10, "m": 10, "w": 8, "hd": 11});
diff --git a/test/longtest.js b/test/longtest.js
index da88fe6..e91033f 100644
--- a/test/longtest.js
+++ b/test/longtest.js
@@ -1,4 +1,14 @@
-// long test
+// Long test, to check for memleaks.
+//
+// This check runs a series of batches of encode/decode steps.
+//
+// The reason we run encode/decode steps in batches is because each step
+// allocates a large buffer. If we ran all steps at the same time, we'd have
+// to allocate all buffers up front, essentially using all the computer's RAM.
+//
+// By batching, we always have sufficient RAM (~1Gb), even on slower computers.
+
+'use strict';
 
 var ECLib = require('../node-eclib.js');
 var enums = require('../eclib-enum.js');
@@ -6,102 +16,121 @@ var ECLibUtil = require('../eclib-util.js');
 var buffertools = require("buffertools");
 var crypto = require('crypto');
 var hexdump = require('hexdump-nodejs');
+var assert = require('assert');
 
-console.log("ECLib testing");
+function do_one_encode_decode(batch_num, num, done) {
+  // var ref_buf = crypto.randomBytes(1000000);
+  var ref_buf = new Buffer(1000000);
+  buffertools.fill(ref_buf, 'z');
 
-var COUNT = 100; //per batch
-var N_BATCHES = 10;
+  eclib.encode(ref_buf,
+    function(status, encoded_data, encoded_parity, encoded_fragment_length) {
+      var k = eclib.opt.k;
+      var m = eclib.opt.m;
 
-var eclib = new ECLib({"bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"], "k": 10, "m": 4, "w": 4, "hd": 5});
+      var x = k - 1; // available data fragments
+      var y = m; // available parity fragments
 
-eclib.init();
+      var fragments = [];
+      var i, j;
+      j = 0;
+      for (i = 0; i < x; i++) {
+        fragments[j++] = encoded_data[i];
+      }
+      for (i = 0; i < y; i++) {
+        fragments[j++] = encoded_parity[i];
+      }
 
-function do_it() {
-    
-    var do_it_count = 0;
-    
-    function batch() {
-	
-	var batch_count = 0;
-	
-	function test_one(num) {
-	    console.log("create " + num);
-	    
-	    var ref_buf = new Buffer(1000000);
-	    buffertools.fill(ref_buf, 'z');    
-	    //var ref_buf = crypto.randomBytes(1000000);
-	    
-	    eclib.encode(ref_buf,
-			 function(status, encoded_data, encoded_parity, encoded_fragment_length) {
-			     console.log(num + " Encode Done status=" + status + " fragment_length=" + encoded_fragment_length);
-			     
-			     k = eclib.opt.k;
-			     m = eclib.opt.m;
-			     
-			     x = k-1; //available data fragments
-			     y = m;   //available parity fragments
-			     
-			     var fragments = [];
-			     var i, j;
-			     j = 0;
-			     //console.log('data:');
-			     for (i = 0;i < x;i++) {
-				 //console.log(hexdump(encoded_data[i]));
-				 fragments[j++] = encoded_data[i];
-			     }
-			     //console.log('codings:');
-			     for (i = 0;i < y;i++) {
-				 //console.log(hexdump(encoded_parity[i]));
-				 fragments[j++] = encoded_parity[i];
-			     }
-			     
-			     eclib.decode(fragments, x+y, encoded_fragment_length, 0,
-					  function(status, out_data, out_data_length) {
-					      console.log(num + " Decode Done status=" + status + " data_length=" + out_data_length);
-					      
-					      //console.log(hexdump(out_data));
-					      
-					      if (buffertools.compare(out_data, ref_buf) == 0)
-						  console.log(num + " OK Buffers are identical");
-					      else
-						  console.log(num + " Nok buffers differ");
-					      
-					      batch_count++;
-					  }
-					 );
-			 }
-			);
-	}
-	
-	var i = 0;
-	for (i = 0;i < COUNT;i++) {
-	    test_one(i);
-	}
-	
-	var i = 0;
-	var work = function(dosomestuff) {
-	    if (batch_count < COUNT) {
-		//process.nextTick(work);
-		setImmediate(work);
-	    } else {
-		console.log("BATCH DONE " + batch_count);
-		do_it_count++;
-		batch();
-	    }
-	}
-	work();
+      eclib.decode(fragments, x + y, encoded_fragment_length, 0,
+        function(status, out_data, out_data_length) {
+          assert.equal(buffertools.compare(out_data, ref_buf), 0);
+          done();
+        }
+      );
     }
+  );
+}
+
+// Do one batch of encode/decode steps.
+//
+// When this batch is done, the next one will be triggered.
+function do_one_batch(num, done) {
+  var num_steps_done = 0;
 
-    var work2 = function(dosomestuff2) {
-	if (do_it_count < N_BATCHES) {
-	    process.nextTick(work2);
-	} else {
-	    console.log("ALL BATCHES DONE");
-	}
+  var i;
+  for (i = 0; i < COUNT; i++) {
+    do_one_encode_decode(num, i, function() {
+      num_steps_done++;
+    });
+  }
+
+  // Checks how many encode/decode steps have been done. When they are all
+  // finished, we'll call the "done" function, which will trigger the next
+  // batch to start running.
+  function checkSteps() {
+    if (num_steps_done >= COUNT) {
+      done();
+    } else {
+      setImmediate(checkSteps);
     }
-    //work2();
+  }
+  checkSteps();
+}
 
-    batch();
+function do_batches(num, done) {
+  // When all batches are done, we'll call the function "done".
+  if (num >= N_BATCHES) {
+    done();
+  } else {
+    process.stdout.write('.');
+    // Not all batches have been ran. We'll call one and when its done,
+    // call the next one, etc, etc.
+    do_one_batch(num, function() {
+      do_batches(num + 1, done);
+    });
+  }
 }
 
-do_it();
+// Number of encodes/decodes per batch
+var COUNT = 100;
+// Number of batches
+var N_BATCHES = 20;
+
+var eclib = new ECLib({
+  "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_CAUCHY"],
+  "k": 10,
+  "m": 4,
+  "w": 4,
+  "hd": 5
+});
+eclib.init();
+
+// Returns heap usage in MiB
+function getHeapUsage() {
+  return process.memoryUsage().heapUsed / 1024 / 1024;
+}
+
+// Monitor heap usage to make sure there are no mem leaks
+function monitorHeapUsage(initialHeapUsage) {
+  // We'll allow memory to increase a bit (1.5) but if it increases more, we'll consider
+  // that to be a memory leak.
+  assert.equal(getHeapUsage() <= initialHeapUsage * 1.5, true,
+    'heap usage has increased too much, it looks like there is a memory leak');
+
+  // If the batches are not done yet done, we'll continue monitoring.
+  if (!done) {
+    setImmediate(function() {
+      monitorHeapUsage(initialHeapUsage);
+    });
+  }
+}
+
+monitorHeapUsage(getHeapUsage());
+
+// Do all batches, starting with the 1st batch.
+var done = false;
+process.stdout.write('memleaks: ');
+do_batches(0, function() {
+  console.log(' done');
+  done = true;
+});
diff --git a/test/reconstruct.js b/test/reconstruct.js
new file mode 100644
index 0000000..3684633
--- /dev/null
+++ b/test/reconstruct.js
@@ -0,0 +1,71 @@
+'use strict';
+
+var ECLib = require('../node-eclib.js');
+var enums = require('../eclib-enum.js');
+var ECLibUtil = require('../eclib-util.js');
+var buffertools = require("buffertools");
+var crypto = require('crypto');
+var hexdump = require('hexdump-nodejs');
+var assert = require('assert');
+
+var ec = new ECLib({
+  "bc_id": enums.BackendId["EC_BACKEND_FLAT_XOR_HD"],
+  "k": 3,
+  "m": 3,
+  "hd": 3
+});
+
+ec.init();
+
+var data = new Buffer("Hello world of Rust ! This is some serious decoding !");
+
+process.stdout.write('reconstruct:');
+
+ec.encode(data, function(status, dataFragments, parityFragments, fragmentLength) {
+    assert.equal(status, 0);
+
+    process.stdout.write('.');
+
+    var allFragments = dataFragments.concat(parityFragments);
+
+    // Lose the 3rd fragment (index 2). This should allow for reconstruction.
+    var missing_fragment_id = 1;
+    allFragments.splice(missing_fragment_id, 1);
+
+    ec.reconstructFragment(allFragments, 2, function(err, missing_fragment) {
+        assert.equal(err, null);
+
+        process.stdout.write('.');
+
+        // Insert the missing fragment.
+        allFragments.splice(2, 0, missing_fragment);
+
+        ec.decode(allFragments, allFragments.length, fragmentLength, false, function(status, decoded_data) {
+            // check that the decoded data is like the initial one
+            assert.equal(Buffer.compare(data, decoded_data), 0);
+
+            process.stdout.write('.');
+
+            // test error callback
+            ec.reconstructFragment([], 3, function(err) {
+                assert.notEqual(err, null);
+                process.stdout.write('.');
+
+                function gb(n) {
+                    var b = [];
+                    for (var i = 0; i < n; i++) {
+                        b.push(new Buffer(crypto.randomBytes(32)));
+                    }
+                    return b;
+                }
+
+                ec.reconstructFragment(gb(16), 1, function(err) {
+                    process.stdout.write('.');
+                    assert.notEqual(err, null);
+                    ec.destroy();
+                    console.log(' done');
+                });
+            });
+        });
+    });
+});
diff --git a/test/reconstruct_mult.js b/test/reconstruct_mult.js
new file mode 100644
index 0000000..814f829
--- /dev/null
+++ b/test/reconstruct_mult.js
@@ -0,0 +1,50 @@
+'use strict';
+
+var ECLib = require('../node-eclib.js');
+var enums = require('../eclib-enum.js');
+var ECLibUtil = require('../eclib-util.js');
+var buffertools = require("buffertools");
+var crypto = require('crypto');
+var hexdump = require('hexdump-nodejs');
+var assert = require('assert');
+
+var ec = new ECLib({
+  "bc_id": enums.BackendId["EC_BACKEND_FLAT_XOR_HD"],
+  "k": 3,
+  "m": 3,
+  "hd": 3
+});
+
+ec.init();
+
+var data = new Buffer("Hello world of Rust ! This is some serious decoding !");
+
+process.stdout.write('reconstruct:');
+
+ec.encode(data, function(status, dataFragments, parityFragments, fragmentLength) {
+    assert.equal(status, 0);
+
+    process.stdout.write('.');
+
+    var allFragments = dataFragments.concat(parityFragments);
+
+    // Lose 3 fragments, 2 of which are data. We should be able to still
+    // recover the data.
+    allFragments.splice(1, 1); // index 1
+    allFragments.splice(1, 1); // index 2
+    allFragments.splice(2, 1); // index 4
+
+    ec.reconstruct(allFragments, [1, 4, 2], function(err, newAllFragments) {
+        assert.equal(err, null);
+
+        process.stdout.write('.');
+
+        ec.decode(newAllFragments, newAllFragments.length, fragmentLength, false, function(status, decoded_data) {
+            // check that the decoded data is like the initial one
+            assert.equal(Buffer.compare(data, decoded_data), 0);
+
+            process.stdout.write('.');
+            console.log(' done');
+        });
+    });
+});
diff --git a/test/threaded.js b/test/threaded.js
index c48be9e..4ee1982 100644
--- a/test/threaded.js
+++ b/test/threaded.js
@@ -1,4 +1,6 @@
-// launch multiple encodes/decodes in parallel
+// launch multiple encodes/decodes in parallel, to test for race conditions
+
+'use strict';
 
 var ECLib = require('../node-eclib.js');
 var enums = require('../eclib-enum.js');
@@ -6,71 +8,78 @@ var ECLibUtil = require('../eclib-util.js');
 var buffertools = require("buffertools");
 var crypto = require('crypto');
 var hexdump = require('hexdump-nodejs');
+var assert = require('assert');
 
-console.log("ECLib testing");
+// Number of tests that are done at any given time.
+var done = 0;
 
 function test_one() {
-    eclib.encode(ref_buf,
-		 function(status, encoded_data, encoded_parity, encoded_fragment_length) {
-		     console.log("Encode Done status=" + status + " fragment_length=" + encoded_fragment_length);
-		     
-		     k = eclib.opt.k;
-		     m = eclib.opt.m;
-		     
-		     x = k-1; //available data fragments
-		     y = m;   //available parity fragments
-		     
-		     var fragments = [];
-		     var i, j;
-		     j = 0;
-		     //console.log('data:');
-		     for (i = 0;i < x;i++) {
-			 //console.log(hexdump(encoded_data[i]));
-			 fragments[j++] = encoded_data[i];
-		     }
-		     //console.log('codings:');
-		     for (i = 0;i < y;i++) {
-			 //console.log(hexdump(encoded_parity[i]));
-			 fragments[j++] = encoded_parity[i];
-		     }
-		     
-			 console.log("Calling decode");
-		     eclib.decode(fragments, x+y, encoded_fragment_length, 0,
-				  function(status, out_data, out_data_length) {
-				      console.log("Decode Done status=" + status + " data_length=" + out_data_length);
-
-				      //console.log(hexdump(out_data));
-				      
-				      if (buffertools.compare(out_data, ref_buf) == 0)
-					  console.log("OK Buffers are identical");
-				      else
-					  console.log("Nok buffers differ");
-				  }
-				 );
-		     console.log("Right after decode called");
-		 }
-		);
+  process.stdout.write('.');
+
+  eclib.encode(ref_buf,
+    function(status, encoded_data, encoded_parity, encoded_fragment_length) {
+      var k = eclib.opt.k;
+      var m = eclib.opt.m;
+
+      var x = k - 1; // available data fragments
+      var y = m; // available parity fragments
+
+      var fragments = [];
+      var i, j;
+      j = 0;
+      for (i = 0; i < x; i++) {
+        fragments[j++] = encoded_data[i];
+      }
+      for (i = 0; i < y; i++) {
+        fragments[j++] = encoded_parity[i];
+      }
+
+      process.stdout.write('.');
+
+      eclib.decode(fragments, x + y, encoded_fragment_length, 0,
+        function(status, out_data, out_data_length) {
+          // If buffers differ, something bad happened.
+          assert.equal(buffertools.compare(out_data, ref_buf), 0);
+
+          // Node is single threaded so this is safe.
+          done += 1;
+          process.stdout.write('.');
+        }
+      );
+    }
+  );
 }
 
+process.stdout.write('threads: ');
+
+var numTests = 4;
+var ref_buf = new Buffer(500000000);
+buffertools.fill(ref_buf, 'z');
+
+process.stdout.write('.');
+
 var eclib = new ECLib({
-    "bc_id": enums.BackendId["EC_BACKEND_FLAT_XOR_HD"],
-    "k": 3,
-    "m": 3,
-    "hd": 3
+  "bc_id": enums.BackendId["EC_BACKEND_JERASURE_RS_VAND"],
+  "k": 3,
+  "m": 3,
+  "hd": 3
 });
-
 eclib.init();
 
-var ref_buf = new Buffer(500000000);
-buffertools.fill(ref_buf, 'z');
-//var ref_buf = crypto.randomBytes(100000);
+process.stdout.write('.');
 
-//console.log(hexdump(ref_buf));
+function monitorState() {
+  if (done < numTests) {
+    setImmediate(monitorState);
+  } else {
+    console.log(' done');
+  }
+}
+monitorState();
 
-console.log("starting");    
-test_one();  
-test_one();
+var numTests = 4;
+for (var i = 0; i < numTests; i++) {
+  test_one();
+}
 
 //eclib.destroy();
-
-//global.gc(); //requires --expose-gc
